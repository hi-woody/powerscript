#!/bin/bash
shopt compat40 2>&1 | grep invalid &>/dev/null && { echo "this app runs on bash >= 4.x, please upgrade"; exit 1;  }
{ 
  # enable strict bash 4.0 mode by disabling higher modes
  for mode in compat49 compat48 compat47 compat46 compat45 compat44 compat43 compat42 compat41; do shopt -u $mode; done
  shopt -s compat40
} &>/dev/null # hide errors of old 4.x versions
settings='# powscript general settings
set -e                         # halt on error
set +m                         #
SHELL="$(echo $0)"             # shellname
SHELLNAME="$(basename $SHELL)" # shellname without path
shopt -s lastpipe              # flexible while loops (maintain scope)
shopt -s extglob               # regular expressions
path="$(pwd)"
selfpath="$( dirname "$(readlink -f "$0")" )"
tmpfile="/tmp/$(basename $0).tmp.$(whoami)"'
strictmode='shopt compat40 2>&1 | grep invalid &>/dev/null && { echo "this app runs on bash >= 4.x, please upgrade"; exit 1;  }
{ 
  # enable strict bash 4.0 mode by disabling higher modes
  for mode in compat49 compat48 compat47 compat46 compat45 compat44 compat43 compat42 compat41; do shopt -u $mode; done
  shopt -s compat40
} &>/dev/null # hide errors of old 4.x versions'
polyfill='# here comes a bash polyfill
# it tries to substitute missing bash commands 
# to provide somewhat compatibility in other shells like bin/sh

noop(){ 
  :>/dev/null
}

shopt(){ 
  noop       
}'
# powscript general settings
set -e                         # halt on error
set +m                         #
SHELL="$(echo $0)"             # shellname
SHELLNAME="$(basename $SHELL)" # shellname without path
shopt -s lastpipe              # flexible while loops (maintain scope)
shopt -s extglob               # regular expressions
path="$(pwd)"
selfpath="$( dirname "$(readlink -f "$0")" )"
tmpfile="/tmp/$(basename $0).tmp.$(whoami)"
declare -A footer
footer["async"]="
# wait for all async child processes (because \"await ... then\" is used in powscript)
[[ \$ASYNC == 1 ]] && wait
"

footer["tmpfile"]="
# cleanup tmp files
if ls /tmp/\$(basename \$0).tmp.$(whoami)* &>/dev/null; then
  for f in /tmp/\$(basename \$0).tmp.$(whoami)*; do rm \$f; done
fi
"
footer["zero_exit"]="exit 0
"
indent_current=0
indent_last=0
stack=()
anonymous_funcs=0

getindent(){
  [[ ! ${1:0:1} =~ ([ \t]) ]] && echo 0 && return 0 
  echo "$1" | sed "s/\n/ /g" | awk '{ match($0, /^ */); printf("%d", RLENGTH) }' | sed 's/00/0/g'
}
  
add_anonymous_func(){
  anonymous_funcs=$((anonymous_funcs+1))
}

push (){ 
  var="$1"; shift 1; eval "$var+=($(printf "'%s' " "$@"))"; 
}

makeindent(){  
  for((i=0;i<$1;i++)); do printf " "; done
}

stack_pop(){
  index=${#stack[@]}
  index=$((index-1))
  [[ $index == "-1" ]] && return 0
  [[ "$1" =~ ^([ ]*else) ]] && echo "$1" && continue # ignore else
  lastitem="${stack[$index]}"
  unset stack["$index"]
  echo -e "$(makeindent $((indent_last-2)) )$lastitem"
  if ! (( (indent_last-2) == indent_current )); then 
    indent_last=$((indent_last-2))
    stack_pop "$1"
  fi
}

stack_update(){
  indent_last="$indent_current"
  indent_current=$(getindent "$1")
  [[ -n $DEBUG ]] && echo ">> $indent_last|$indent_current|stacksize:${#stack[@]}"
  if ((indent_current < indent_last)); then stack_pop "$1"; fi
}

get_array_code(){
  printf '"'
  printf "\${$1[$2]}"
  printf '"'
}

transpile_all(){
  [[ -n $1 ]] && [[ $1 == '--noquotes' ]] && NO_QUOTES=1
  while IFS="" read -r line; do
    i=$(getindent "$line")
    [[ "$line" =~ ^(#)  ]] && local _comment="#"
    [[ "$line" =~ "={}" ]] && echo "$_comment$(makeindent $i)declare -A ${line/=\{\}/}" && continue
    [[ "$line" =~ "=[]" ]] && echo "$_comment$(makeindent $i)declare -a ${line/=\[\]/}" && continue
    [[ ! $NO_QUOTES     ]] && [[ "$line" =~ ([ ]\$[A-Za-z_0-9@]) ]] && line="$(echo "$line" | sed -E 's/([ =])\$([a-zA-Z_0-9@]+)/\1"$\2"/gi' )"
    echo "$line"
  done
}

transpile_for(){
  push stack "done"
  local arr="$(echo "$1" | awk '{ print $4 }' )"
  local arr2nd="$(echo "$1" | awk '{ print $5 }' )"
  local i=$(( $(getindent "$code") + 2 ))
  args=""
  code="$1; do"
  indent="$(makeindent $i)"
  # iterate over string (starts with $ or has more than 1 argument)
  if [[ ${arr:0:1} =~ ^([$]) || ${#arr2nd} != 0 ]]; then 
    args="--noquotes"
  # iterate over associative array
  elif [[ "$code" =~ [a-zA-Z_0-9],[a-zA-Z_0-9] ]]; then
    local key="$(echo "$code" | awk '{ print $2 }' | awk -F',' '{ print $1 }')"
    local value="$(echo "$code" | awk '{ print $2 }' | awk -F',' '{ print $2 }')"
    code="$code\n$indent$value=$(get_array_code $arr "\$$key")"
    code="${code/,$value/}"
    code="${code/ of / in }"
    code="${code/ $arr/ $(get_array_code "!$arr" @)}";
  elif [[ ! "$arr" == "\$@" ]]; then
    # iterate over indexed array
    local key="$(echo "$code" | awk '{ print $2 }')"
    code="${code/ $arr/ $(get_array_code $arr @)}"
  fi
  echo -e "$code" | transpile_all ${args}
}

transpile_while(){
  push stack "done"
  code="$(transpile_condition while "$1" "$2")"
  code="$code; do"
  echo "$code" | transpile_all
}

transpile_if(){
  push stack "fi"
  code="$(transpile_condition "if" "$1" "$2")"
  code="$code; then"
  echo "$code" | transpile_all
}

transpile_condition(){
  form=$1
  code="${2/$form not/$form !}"
  firstvar="${code/\! /}"
  firstvar="$(echo "$firstvar" | awk '{ print $2 }')"
  code="${code// and / && }"
  code="${code// or / || }"
  code="${code//> /-gt }"
  code="${code//>= /-ge }"
  code="${code//< /-lt }"
  code="${code//<= /-le }"
  code="${code//!= /-ne }"
  [[ "$code" =~ ($form[ ]) && "$firstvar" =~ ^([\"\$-]) ]] && code="${code/$form /$form [[ }"
  code="${code/match /=~ }"
  [[ "$code" =~ "[[" ]] && code="$code ]]"
  code="${code// is / == }"
  echo "$code"
}

transpile_then(){
  cmd="${*/await /}"
  cmd="$(echo "$cmd" | sed "s/'/\"/g")" # ugly hack..*FIXME*
  [[ ! -n $3 ]] && category="then" || category="$3"
  add_anonymous_func 
  funcindex=$anonymous_funcs
  echo -e "\n# async code"
  echo "_"$category"_$funcindex(){"
  local curindent=$(getindent "$1")
  local indent="$(makeindent $curindent)"
  if [[ $category =~ "pipe" ]]; then
    add_anonymous_func
    push stack "}\n$indent""async_$category _then_when_done_$anonymous_funcs "_"$category"_"$funcindex ${cmd/ then*/}"
    push stack ""
  else
    push stack "}\n$indent""async_$category "_"$category"_"$funcindex ${cmd/ then/}"
  fi
}

transpile_when_done(){
  local curindent=$(getindent "$1")
  echo -e "}\n_then_when_done_"$anonymous_funcs"(){"
}

transpile_switch(){
  push stack "esac"
  echo "${1/switch/case} in" 
}

transpile_case(){
  push stack "  ;;"
  echo "${1/case /})"
}

transpile_array_push(){
  code="${1/+=/+=(}"
  echo "$code)"
}

transpile_array_get(){
  code="${1/\$/\"\${}"
  echo "$code}\""
}

transpile_foreachline_from(){
  file="${1/[ ]?for line from /}"
  local curindent=$(getindent "$1")
  local indent="$(makeindent $curindent)"
  echo "$indent""while IFS=\"\" read -r line; do"
  push stack $indent"done < $file"
}

transpile_function(){
  push stack "}"
  local curindent=$(( $(getindent "$1") + 2 ))
  local indent="$(makeindent $curindent)"
  fields="${1//*\(/}"
  fields="${fields//\)*/}"
  fields="${fields// /}"
  fields="${fields//,/ }"
  echo "${1//\(*\)/()}{"
  local i=1; 
  for field in $fields; do echo "$indent""local $field=\"\${$i}\""; i=$((i+1)); done
}
######################### begin-of-powscript-functions
powfunctions="async_pipe async_pipe_each_line async_then compose empty filter isset keys last map mappipe math on pick values"
# async_then <done_callback> <pipe_function> <function> <args..>
async_pipe() {
  cb=$1   ; shift
  pcb=$1  ; shift
  func=$1 ; shift
  { set +e; $func "$@" | $pcb; $cb $?; }&
  ASYNC=1
}
# async_then <done_callback> <pipe_line_function> <function> <args..>
async_pipe_each_line() {
  cb=$1   ; shift
  pcb=$1  ; shift
  func=$1 ; shift
  { 
    set +e
    $func "$@" | while IFS='' read line; do 
      $pcb "$line"
    done; 
    $cb $?
  }&
  ASYNC=1
}
# async_then <done_callback> <function> <args..>
async_then() {
  {
    set +e
    done="$1";  shift ; "$@" 
    $done $? # callback
  }&
  ASYNC=1
}
# compose function out of 2 functions
# example: 
#   compose functionname func2 func1
#   functionname "this is input"
compose() {
  result_fun=$1; shift ; f1=$1; shift ; f2=$1; shift
  eval "$result_fun() { $f1 \"\$($f2 \"\$*\")\"; }"
}
# example: empty "" && echo "empty string"
empty(){
  [[ "${#1}" == 0 ]] && return 0 || return 1
}
# usage: filter foo myfunc
filter(){
  map $1 | pipemap $2 
}
# example: isset "" && echo "not empty string" || echo "empty string"
isset(){
  [[ ! "${#1}" == 0 ]] && return 0 || return 1
}
# example: foreach foo keys
keys(){
  echo "$1"
}
last(){
  [[ ! -n $1 ]] && return 1 
  echo "$(eval "echo \${$1[@]:(-1)}")"
}
# maps a pipe stream to individual calls
# example:
#  map foo somefunction
map(){
  local arr="$1"; shift; local func="$1"; shift;
  eval "for i in \"\${!$arr[@]}\"; do $func \"\$@\" \"\$i\" \"\${$arr[\$i]}\"; done"
}
mappipe(){
  func="$1"; shift
  ( while read -r line; do $func "$@" "$line"; done )
}
math(){
  if [[ -n "$2" ]]; then
    which bc &>/dev/null && { echo "scale=$2;$1" | bc; } || echo "bc is not installed"; 
  else echo $(($1)); fi
}
#  1) SIGHUP	 2) SIGINT	 3) SIGQUIT	 4) SIGILL	 5) SIGTRAP
#  6) SIGABRT	 7) SIGBUS	 8) SIGFPE	 9) SIGKILL	10) SIGUSR1
# 11) SIGSEGV	12) SIGUSR2	13) SIGPIPE	14) SIGALRM	15) SIGTERM
# 16) SIGSTKFLT	17) SIGCHLD	18) SIGCONT	19) SIGSTOP	20) SIGTSTP
# 21) SIGTTIN	22) SIGTTOU	23) SIGURG	24) SIGXCPU	25) SIGXFSZ
# 26) SIGVTALRM	27) SIGPROF	28) SIGWINCH	29) SIGIO	30) SIGPWR
# 31) SIGSYS	34) SIGRTMIN	35) SIGRTMIN+1	36) SIGRTMIN+2	37) SIGRTMIN+3
# 38) SIGRTMIN+4	39) SIGRTMIN+5	40) SIGRTMIN+6	41) SIGRTMIN+7	42) SIGRTMIN+8
# 43) SIGRTMIN+9	44) SIGRTMIN+10	45) SIGRTMIN+11	46) SIGRTMIN+12	47) SIGRTMIN+13
# 48) SIGRTMIN+14	49) SIGRTMIN+15	50) SIGRTMAX-14	51) SIGRTMAX-13	52) SIGRTMAX-12
# 53) SIGRTMAX-11	54) SIGRTMAX-10	55) SIGRTMAX-9	56) SIGRTMAX-8	57) SIGRTMAX-7
# 58) SIGRTMAX-6	59) SIGRTMAX-5	60) SIGRTMAX-4	61) SIGRTMAX-3	62) SIGRTMAX-2
# 63) SIGRTMAX-1	64) SIGRTMAX	

on() {
    func="$1" ; shift
    for sig ; do
        trap "$func $sig" "$sig"
    done
}

#trap_with_arg func_trap INT TERM EXIT
# example: pick foo "index"
pick(){                                                                         
  [[ ! -n $2 ]] && return 1 
  local output="$(eval "echo \${$1[$2]}")"
  [[ ! ${#output} == 0 ]] && echo "$output" 
}
# example: foreach foo values
values(){
  echo "$2"  
}
######################### end-of-powscript-functions
# parse args
date=$(date +%Y%m%d%H%M%S)
rand=$(cat /dev/urandom | tr -cd [:alnum:] | head -c 4)
ID=$date"_"$rand
includefuncs=""
requires=""
tmpfile="/tmp/.$(whoami).pow.$date_$rand"
ps1="${PS1//\\u/$USER}"; p="${p//\\h/$HOSTNAME}"
evalstr=""
evalstr_cache=""
shopt -s extglob
shopt -s compat40
[[ -n $runtime ]] && runtime=$runtime || runtime=bash

input=$1
if [[ ! -n $startfunction ]]; then 
  startfunction=runfile
fi

empty "$1" && {
  echo 'Usage:
    
   powscript <file.pow>                                     run powscript directly                        
   powscript --compile [--sh] <file.pow>                    compile to bash [or (experimental) POSIX sh]  
   powscript --lint <file.pow>                              crude linter                                  
   powscript --evaluate <powscript string>                  run powscript string directly                 
   powscript --interactive                                  interactive console                            
   echo <powscript string> | PIPE=1 powscript --compile     output bashcode                               
   echo <powscript string> | PIPE=1 powscript --evaluate    run bashcode                                  
   cat foo.bash            | powscript --tosh > foo.sh      convert bash to sh (experimental)             
                                                                                                          
                                                                                                          
   note: PIPE=1 allows input from stdin, PIPE=2 as well   ┌─────────────────────────────────────────────────────┐
   but without the fat                                    │ docs: https://github.com/coderofsalvation/powscript │
  ';
}

for arg in "$@"; do
  case "$arg" in
    --sh)
      runtime=sh
      shift
      ;;
    --tosh)
      startfunction=tosh
      shift
      ;;
    --interactive)
      startfunction="console process"
      shift
      ;;
    --evaluate)
      startfunction=evaluate
      shift
      ;;
    --lint)
      startfunction=lint
      shift
      ;;
    --compile) 
      startfunction=compile
      shift
      ;;
  esac
done

transpile_sh(){
  if [[ $runtime == "bash" ]]; then 
    cat
  else
    cat                                             \
      | sed "s/\[\[/\[/g;s/\]\]/\]/g"               \
      | sed "s/ == / = /g"                          \
      | sed "s/\&>\(.*[^;]\)[; $]/1>\1 2>\1; /g"    \
      | transpile_all
  fi
}

transpile_sugar(){
  while IFS="" read -r line; do 
    stack_update "$line"
    [[ "$line" =~ ^(require |require_cmd|#)           ]] && continue
    [[ "$line" =~ (\$[a-zA-Z_0-9]*\[)                 ]] && transpile_array_get "$line"                  && continue
    [[ "$line" =~ ^([ ]*for line from )               ]] && transpile_foreachline_from "$line"           && continue
    [[ "$line" =~ ^([ ]*for )                         ]] && transpile_for "$line"                        && continue
    [[ "$line" =~ ^([ ]*when done)                    ]] && transpile_when_done "$line"                  && continue
    [[ "$line" =~ ^([ ]*await .* then for line)       ]] && transpile_then "$line" "pl" "pipe_each_line" && continue
    [[ "$line" =~ ^([ ]*await .* then \|)             ]] && transpile_then "$line" "p"  "pipe"           && continue
    [[ "$line" =~ ^([ ]*await .* then)                ]] && transpile_then "$line"                       && continue
    [[ "$line" =~ ^([ ]*if )                          ]] && transpile_if  "$line"                        && continue
    [[ "$line" =~ ^([ ]*switch )                      ]] && transpile_switch "$line"                     && continue
    [[ "$line" =~ ^([ ]*while )                       ]] && transpile_while "$line"                      && continue
    [[ "$line" =~ ^([ ]*case )                        ]] && transpile_case "$line"                       && continue
    [[ "$line" =~ ([a-zA-Z_0-9]\+=)                   ]] && transpile_array_push "$line"                 && continue
    [[ "$line" =~ ^([a-zA-Z_0-9:]*\([a-zA-Z_0-9, ]*\)) ]] && transpile_function "$line"                   && continue
    echo "$line" | transpile_all
  done <  "$1"
  stack_update ""
}

cat_requires(){
  while IFS="" read -r line; do 
    if [[ "$line" =~ ^(require_cmd ) ]]; then                                           # include require_cmd dependency checks
      local cmd="${line//*require_cmd /}"; cmd="${cmd//[\"\']/}"
      printf "%-30s %s\n" "which $cmd &>/dev/null" "|| { echo \"dependency error: it seems '$cmd' is not installed (please install it)\"; }"
    fi
    if [[ "$line" =~ ^(require ) ]]; then                                               # include require-calls
      local file="${line//*require /}"; file="${file//[\"\']/}"
      if [[ ! -f $file ]]; then echo "echo 'compile error: couldn't find required file: $file'; exit 1;"; exit 1; fi
      echo -e "#\n# $line (included by powscript\n#\n"
      cat "$file";
    fi
  done < "$1"
}

transpile_functions(){
  # *FIXME* this is bruteforce: if functionname is mentioned in textfile, include it
  declare -A seen
  local allfuncs="(${powfunctions// /|})"
  local anydel="\\\'\\\\\" "
  local odel="\\\($anydel" # open delimiters
  local cdel="\\\)$anydel" # close delimiters
  local nodel="[^\\\(\\\)$anydel]"
  local namechar='[a-zA-Z0-9_-]'
  local startsname='(?<!'"${namechar}"')'
  local endsname='(?!'"${namechar}"')'
  local regex="[$odel]?${startsname}$allfuncs${endsname}[$cdel]?"
  while IFS="" read -r line; do
    matched_funcs="$(echo "$line" | grep -oP "$regex" | grep -oP "($nodel)+" || printf '')"
    for func in $matched_funcs; do
       if [[ ${seen["$func"]} != true ]]; then
         includefuncs="$includefuncs $func";
         seen[$func]=true
       fi
    done;
  done < "$1"
  [[ ! ${#includefuncs} == 0 ]] && echo -e "#\n# generated by powscript (https://github.com/coderofsalvation/powscript)\n#\n"
  for func in $includefuncs; do 
    declare -f $func; echo ""; 
  done
}

compile(){
  if [[ -n $PIPE ]]; then 
    cat | lint_pipe > $tmpfile
  else
    local dir="$(dirname "$1")"; local file="$(basename "$1")"; cd "$dir" &>/dev/null
    { cat_requires "$file" ; echo -e "#\n# application code\n#\n"; cat "$file"; } | lint_pipe > $tmpfile
  fi
  [[ ! $PIPE == 2 ]] && {
    echo -e "#!/bin/$runtime\n"
    [[ ! $runtime == "bash" ]] && echo -e "$polyfill"
    echo -e "$settings"
  }
  transpile_sugar "$tmpfile" | grep -v "^#" > $tmpfile.code
  transpile_functions $tmpfile.code
  {
    cat $tmpfile.code
    [[ ! $PIPE == 2 ]] && for i in ${!footer[@]}; do echo "${footer[$i]}"; done 
  } | transpile_sh
  rm $tmpfile
  rm $tmpfile.code
}


process(){
  evalstr="$evalstr\n""$*"
  if  [[ ! "$*" =~ ^([A-Za-z_0-9]*=) ]]  && \
      [[ ! "$*" =~ \)$ ]]                && \
      [[ ! "$*" =~ ^([ ][ ]) ]]; then 
    evaluate "$evalstr"
  fi
}

evaluate(){
  [[ -n $PIPE ]] && cat > $tmpfile || echo -e "$*" | lint_pipe > $tmpfile
  evalstr_cache="$evalstr_cache\n$*"
  [[ -n $DEBUG ]] && echo "$(transpile_sugar $tmpfile)"
  eval "$(transpile_sugar $tmpfile)"
  evalstr=""
}

tosh(){
  runtime=sh
  transpile_sh
}

edit(){
  local file=/tmp/$(whoami).pow
  echo -e "#!/usr/bin/env powscript$evalstr_cache" | grep -vE "^(edit|help)" > $file && chmod 755 $file
  $EDITOR $file
}

help(){
  echo '
  FUNCTION                  foo(a,b)
                              switch $a
                                case [0-9])
                                  echo 'number!'
                                case *)
                                  echo 'anything!'

  IF-STATEMENT              if not $j is "foo" and $x is "bar"
                              if $j is "foo" or $j is "xfoo"
                                if $j > $y and $j != $y or $j >= $y
                                  echo "foo"
  
  READ FILE BY LINE         for line from $selfpath/foo.txt
                              echo "->"$line

  REGEX                     if $f match ^([f]oo)
                              echo "foo found!"    

  MAPPIPE                   myfunc()
                              echo "line=$1"

                            echo -e "foo\nbar\n" | mappipe myfunc
                            # outputs: 'value=foo' and 'value=bar'

  MATH                      math '9 / 2'
                            math '9 / 2' 4
                            # outputs: '4' and '4.5000'
                            # NOTE: the second requires bc 
                            # to be installed for floatingpoint math

  ASYNC                     myfunc()
                              sleep 1s
                              echo "one"

                            await myfunc 123 then
                              echo "async done"

                            # see more: https://github.com/coderofsalvation/powscript/wiki/Reference

  CHECK ISSET / EMPTY       if isset $1
                              echo "no argument given"
                            if not empty $1
                              echo "string given"
  
  ASSOC ARRAY               foo={}
                            foo["bar"]="a value"

                            for k,v in foo
                                echo k=$k
                                  echo v=$v
                                    
                                  echo $foo["bar"]

  INDEXED ARRAY             bla=[]
                            bla[0]="foo"
                            bla+="push value"

                            for i in bla
                                echo bla=$i

                                echo $bla[0]


  SOURCE POWSCRIPT FILE     require foo.pow

  SOURCE BASH FILE          source foo.bash

  see more at: https://github.com/coderofsalvation/powscript/wiki/Reference
  
  ' | less
}


lint(){
  cat "$1" | lint_pipe
}

lint_pipe(){
  code="$(cat -)"
  output="$(echo "$code" | awk -F"[  ]" '{ j=0; for(i=1;i<=NF && ($i=="");i++); j++; if( ((i-1)%2) != 0 ){ print "indent error: "$j" "$i; }  }')"
  if [[ ${#output} != 0 ]]; then 
    echo "$output" 1>&2
    exit 1
  else
    echo "$code"
    return 0
  fi
}

console(){
  echo "hit ctrl-c to exit powscript, type 'edit' to launch editor, and 'help' for help"
  while IFS="" read -r -e -d $'\n' -p "> " line; do
    "$1" "$line" || [[ $? =~ (0|1|2|3|13|15) ]]
    history -s "$line"
  done
}

runfile(){
  file=$1; shift;
  eval "$(compile "$file")"
}

${startfunction} "$@" #"${0//.*\./}"

# parse args
includefuncs=""
shopt -s extglob

input="$1"
[[ ! -n $startfunction ]] && startfunction=runfile

for arg in "$@"; do
  case "$arg" in
    --compile) 
      startfunction=compile
      input="$2"
      ;;
  esac
done

empty "$1" && {
  echo 'Usage:
     powscript <file.powscript>
     powscript --compile <file.powscript>
  ';
}

transpile_sugar(){
  [[ ! ${#includefuncs} == 0 ]] && echo -e "\n#\n# application code\n#\n"
  while IFS="" read line; do 
    stack_update "$line"
    [[ "$line" =~ (\$[a-zA-Z_0-9]*\[)              ]] && transpile_array_get "$line"  && continue
    [[ "$line" =~ ^([ ]*for )                      ]] && transpile_for "$line"        && continue
    [[ "$line" =~ ^([ ]*if )                       ]] && transpile_if  "$line"        && continue
    [[ "$line" =~ ^([ ]*switch )                   ]] && transpile_switch "$line"     && continue
    [[ "$line" =~ ^([ ]*case )                     ]] && transpile_case "$line"       && continue
    [[ "$line" =~ ([a-zA-Z_0-9]\+=)                ]] && transpile_array_push "$line" && continue
    [[ "$line" =~ \(\)$                       ]] && transpile_function "$line"   && continue
    echo "$line" | transpile_all
  done <  $input
  stack_update ""
}

transpile_functions(){
  # *FIXME* this is bruteforce: if functionname is mentioned in textfile, include it
  while IFS="" read line; do 
    regex="(${powfunctions// /|})" 
    echo "$line" | grep -qE "$regex" && {
      for func in $powfunctions; do
        [[ "$line" =~ ^([ ]*)$func([ ]*) ]] && includefuncs="$includefuncs $func"
      done;
    }
  done <  $input
  [[ ! ${#includefuncs} == 0 ]] && echo -e "#\n# generated by powscript (https://github.com/coderofsalvation/powscript)\n#\n"
  for func in $includefuncs; do
    declare -f $func
  done
}

compile(){
  transpile_functions
  transpile_sugar
}

runfile(){
  shift 
  eval "$(compile $input)"
}

$startfunction "$@" #"${0//.*\./}"
